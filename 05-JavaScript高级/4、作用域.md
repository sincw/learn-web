# 作用域


作用域是由你在写代码时将变量和块作用域写在哪里来决定的。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

### 1、引擎，编译器，作用域

#### 1)JS编译原理简述
JavaScript是一门解释执行的语言，他不需要提前编译。

在传统的编译语言的流程中，程序的一段代码在执行前会被编译：主要包括以下三个步骤。

##### 1：词法分析
Var a = 2;
这句代码会被分解有意义的代码块，称为语法单元。 var ,a ,=, 2,。空格是否会被当做与词法单元取决于空格在这门语言中是否有意义。

##### 2：语法分析
这个过程将我们的词法单元数组转换成了一个由元素逐级嵌套所组成的代表了程序语法结构的树。称为语法抽象数。
将[var,a,=,2]
转换成具有语法结构的树
Var--
    |---  a
    |---- 2
    
##### 3：代码生成
将我们的语法抽象树转换为可执行的代码，这个过程跟语言，目标平台等息息相关。最终结果就是将var a = 2;转换成一组机器指令，创建了一个a的变量，为其分配内存，并将一个值存储在a中。

JavaScript来说，他的编译发生在代码执行前几微秒。JavaScript在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。用尽各种方法来保证性能最佳。

#### 2)作用域里的角色

##### 引擎
负责整个JS程序的编译及执行

##### 编译器
负责语法分析及代码生成

##### 作用域
负责提供查询所有声明的标识符，有一套严格的规则，确定当前执行的代码对这些标识符的访问权限。

当我们执行var a =2时以上角色的作用：

1.遇到var a，“编译器”找到“作用域”说，你在A仓库的A1房间见过“a”箱子吗？ 
“作用域”回答：没有见过。于是编译器要求作用域新买了一个箱子，放在A1房间，编号为“a”;

2.接下来编译器为引擎生成运行时所需的代码，这些代码用来处理a = 2的赋值操作。
接下来引擎询问作用域，A1房间是否有a箱子？作用域回答：有。于是引擎将2 放进了a箱子。如果A1房间没有没有a箱子，那作用域就会去A仓库找，如果A仓库没有，继续往上面找。如果找不到，引擎就会抛出异常。

3.变量的赋值操作会执行两个动作
	1）编译器首先会在当前作用域声明一个变量，如果之前没有被声明过，
	2）运行时引擎在作用域中查找该变量，如果能够找到，就会对它赋值。
	

- 引擎会在结束JS代码之前对其进行编译，找到所有声明，将他们关联起来（变量和函数都会被提升，函数优先与变量）

- 函数可以创建的作用域，函数作用域可以将内部的变量和函数定义隐藏起来。

```javascript
Function foo(a){
	Console.info(a);//2
}
```

引擎执行过程中需要查找变量，这时候作用域会协助他。
查询类型主要有两种，LHS查询和RHS查询
LHS查询：
a = 2,赋值引用   这里并不关心 a箱子里面是什么，只是把a箱子里面的东西拿出来，把2放进去
RHS查询：
Console.info(a); 取值引用，我们这里关心的是a箱子里面是什么，并把a箱子里面的东西拿来用。

function foo(a) {
console.log( a ); // 2
}
foo( 2 );

引擎：作用域，我需要为找到foo （RHS ）。你见过它吗？
作用域：见过见过，编译器那小子刚叫我买的箱子。它是一个函数，给你。
引擎：哥们太够意思了！好吧，我来执行一下foo。
引擎：作用域，还有个事儿。我需要为a 然后给他赋值（LHS），这个你见过吗？
作用域：这个也见过，编译器最近把它声名为foo 的一个形式参数一起放进箱子了，拿去吧。
引擎：大恩不言谢，你总是这么棒。现在我要把2 赋值给a。
引擎：哥们，不好意思又来打扰你。我要找到console （RHS ），你见过它吗？
作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 放在大仓库里了，来，给你。
引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。
引擎：哥们，能帮我再找一下a(RHS)吗？虽然我记得它，但想再确认一次。
作用域：放心吧，这个变量没有变动过，拿走，不谢。
引擎：真棒。我来把a 的值，也就是2，传递进log(..)。




##### 异常

当我们寻找一个变量找不到时，如果使用的是RHS方式找不到变量，引擎会抛出异常

如果是LHS方式找不到变量，作用域就会创建一个该变量，将其返还给引擎。这就是JS中的不使用var声明时， 声明全局变量的原因。前提这是在非严格模式下。在严格模式下，禁止自动或者隐式的创建变量，会抛出referenceError异常。



### 2、作用域链

```javascript
var A = 1000;
function foo(a){
    var b = a * 2;
    function bar(c){
        console.info(c + b + A + this.d);
    }
    return bar;
}

var f1 = foo(100);
var sincw = {
    d:1,
    fun:f1
};
sincw.fun(10);
dir(sincw.fun);
```

早浏览器控制台输入上述代码，在图中出现了3个作用域

![](imgs/1534671784(1).jpg)

各个作用域中有什么？我们可以明确的看到，sincw.fun所接触到的域，都被记录在scope变量中。

![](imgs/1534671606(1).jpg)

### 3、查找

作用域链的结构和相互之间的关系给JS引擎提供了足够的信息，引擎顺着作用域链去查找标识符的位置，作用域
查找会在找到第一个匹配的标识符时停止，由内向外，知道找到为止，在全局作用域找不到就会抛出异常。


在上述的代码片段中，引擎执行console.info时，

- 1.它首先重最内部的作用域，也就是bar(..)内部开始寻找，找到了c,没有找到b,A,d
- 2.然后顺着作用域链[[Scopes]]按索引访问找到了closure对象,取得了b,没有找到A和d，
- 3.在顺次访问Script对象，找到了d,找不到A，
- 4.在顺次访问Global对象，找到了A，执行函数。

### 4、欺骗词法

我们可以通过eval函数欺骗浏览器。让浏览器认为那段代码本来就是声明在那的。eval函数对作用域的环境进行了修改。
它在foo(..)内部创建了一个变量e,屏蔽了外部作用域中的同名变量

![](imgs/1534673309(1).jpg)

可以看到正常声明和使用eval声明时的区别，使用eval声明是作用域保留了更多的变量。这就会带来性能的损耗，当然不仅仅只有是上面例子那样。
因此我们是写代码时尽量不使用eval，with等来欺骗浏览器，他们会导致引擎不对使用他们的地方进行性能优化（浏览器不确定eval()中会传递过来什么），他的副作用大于他的作用。


