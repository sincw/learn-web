# 作用域


作用域是由你在写代码时将变量和块作用域写在哪里来决定的。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

### 1、引擎，编译器，作用域
（待完善）

引擎会在结束JS代码之前对其进行编译，找到所有声明，将他们关联起来（变量和函数都会被提升）

函数可以创建的作用域，函数作用域可以将内部的变量和函数定义隐藏起来。


### 2、作用域链

```javascript
var A = 1000;
function foo(a){
    var b = a * 2;
    function bar(c){
        console.info(c + b + A + this.d);
    }
    return bar;
}

var f1 = foo(100);
var sincw = {
    d:1,
    fun:f1
};
sincw.fun(10);
dir(sincw.fun);
```

早浏览器控制台输入上述代码，在图中出现了3个作用域

![](imgs/1534671784(1).jpg)

各个作用域中有什么？我们可以明确的看到，sincw.fun所接触到的域，都被记录在scope变量中。

![](imgs/1534671606(1).jpg)

### 3、查找

作用域链的结构和相互之间的关系给JS引擎提供了足够的信息，引擎顺着作用域链去查找标识符的位置，作用域
查找会在找到第一个匹配的标识符时停止，由内向外，知道找到为止，在全局作用域找不到就会抛出异常。


在上述的代码片段中，引擎执行console.info时，

- 1.它首先重最内部的作用域，也就是bar(..)内部开始寻找，找到了c,没有找到b,A,d
- 2.然后顺着作用域链[[Scopes]]按索引访问找到了closure对象,取得了b,没有找到A和d，
- 3.在顺次访问Script对象，找到了d,找不到A，
- 4.在顺次访问Global对象，找到了A，执行函数。

### 4、欺骗词法

我们可以通过eval函数欺骗浏览器。让浏览器认为那段代码本来就是声明在那的。eval函数对作用域的环境进行了修改。
它在foo(..)内部创建了一个变量e,屏蔽了外部作用域中的同名变量

![](imgs/1534673309(1).jpg)

可以看到正常声明和使用eval声明时的区别，使用eval声明是作用域保留了更多的变量。这就会带来性能的损耗，当然不仅仅只有是上面例子那样。
因此我们是写代码时尽量不使用eval，with等来欺骗浏览器，他们会导致引擎不对使用他们的地方进行性能优化（浏览器不确定eval()中会传递过来什么），他的副作用大于他的作用。


